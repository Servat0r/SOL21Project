#include <fdata.h>


/**
 * @brief Utility macro for checking that client identifier is "in range"
 */
#define CHECK_MAXCLIENT(fdata, client) \
	do { \
		if (client > fdata->maxclient){ \
			RWL_UNLOCK(&fdata->lock); \
			errno = EINVAL; \
			return -1; \
		} \
	} while (0);


//TODO Se fallisce anche una sola volta:
//Versione1: il server va in shutdown (pthread_kill(SIGQUIT, ...))
//Versione2: tutti i file su cui fallisce sono invalidati ed eliminati dal chiamante (un worker con fss_resize tipicamente)
//Versione3: non si invalida nulla, ma si restituisce "connection failed" (la fss_resize viene chiamata all'arrivo di una nuova connessione, il worker "prepara"
//il server a eseguire richieste da quel client)
//In generale, ogni file avrà un maxclient diverso per gestire questi edge-cases
/**
 * @brief Resizes the current array of clients such that client can be inserted in.
 * @return 0 on success (client is suitable for current length, or fdata->clients has
 * been correctly realloc'd), -1 on error.
 * Possible errors are:
 *	- EINVAL: invalid arguments (fdata == NULL, client < 0);
 *	- ENOMEM (system out of memory, set by malloc);
 */
int fdata_resize(fdata_t* fdata, int client){
	if (!fdata || (client < 0)){ errno = EINVAL; return -1; }

	RWL_WRLOCK(&fdata->lock);
	
	if (client > fdata->maxclient){
		unsigned char* ptr = realloc(fdata->clients, (client + 1) * sizeof(unsigned char));
		if (!ptr){
			RWL_UNLOCK(&fdata->lock);
			errno = ENOMEM;
			return -1;
		} else {
			fdata->clients = ptr;
			memset(fdata->clients + fdata->maxclient + 1, 0, (client - fdata->maxclient)*sizeof(unsigned char)); /* NEVER fails */
			fdata->maxclient = client;
		}
	}
	RWL_UNLOCK(&fdata->lock);
	
	return 0;
}


/**
 * @brief Initializes a fdata_t object to contain an empty (closed) file and a (current) number of
 * possible opening clients of nclients.
 * @return Pointer to fdata_t object on success, NULL on error.
 * Possible errors are:
 *	- EINVAL: invalid arguments;
 *	- ENOMEM (system out of memory, set by malloc / calloc);
 *	- any error generated by rwlock_init.
 */
fdata_t* fdata_create(int maxclient, int creator, bool locking){ /* -> fss_create */

	if ((creator > maxclient) || (creator < 0) || (maxclient < 0)){
		errno = EINVAL;
		return NULL;
	}
	
	fdata_t* fdata = malloc(sizeof(fdata_t));
	if (!fdata){
		errno = ENOMEM;
		return NULL;
	} //TODO La connessione verrà chiusa dopo aver inviato un errore
	
	memset(fdata, 0, sizeof(fdata_t));
	fdata->data = NULL;
	fdata->size = 0;
	
	fdata->waiting = tsqueue_init();
	
	if (!fdata->waiting){
		free(fdata);
		errno = ENOMEM;
		return NULL;
	} //TODO La connessione verrà chiusa dopo aver inviato un errore
	
	fdata->clients = malloc((maxclient + 1) * sizeof(char));
	if (!fdata->clients){
		/* If queue CANNOT be destroyed, we CANNOT avoid (at least) a memory leak */
		SYSCALL_EXIT(tsqueue_destroy(fdata->waiting, dummy), "fdata_create: while destroying waiting queue");
		free(fdata);
		errno = ENOMEM;
		return NULL;
	} //TODO La connessione verrà chiusa dopo aver inviato un errore (se tsqueue_destroy NON fallisce)
	memset(fdata->clients, 0, (maxclient + 1)*sizeof(char));
	fdata->maxclient = maxclient;
	
	RWL_INIT(&fdata->lock, NULL);
	
	/* Gives access to creator */
	fdata->clients[creator] |= LF_OPEN;
	
	/* Gives ownership to creator if requested */
	if (locking){
		fdata->flags |= O_LOCK;
		fdata->clients[creator] |= (LF_OWNER | LF_WRITE);
	}

	return fdata;
}

//FIXME Mi sembra NON ci sia una race condition a controllare (fdata == NULL), a meno che fdata_destroy non lo setti a NULL, ma se si toglie questo controllo è meglio
//FIXME La open così è fatta COMPLETAMENTE in mutua esclusione, se si abolisce la validità (oppure la si ricontrolla ogni volta che si cambiano 'permessi' si può
//passare a rdlock)
/**
 * @brief Open fdata->data for client identified by client.
 * @return 0 on success, -1 on error, 1 if client has been suspended waiting for lock.
 * Possible errors are:
 *	- EINVAL: invalid arguments (fdata == NULL, client < 0, client > fdata->maxclient);
 *	- EPERM: file not valid;
 *	- EBADF: file already open;
 *	- ENOMEM: unable to allocate memory;
 *	- any error by rwlock_write_*.
 */
int fdata_open(fdata_t* fdata, int client, bool locking){ /* -> fss_open */

	if ((!fdata) || (client < 0)){ errno = EINVAL; return -1; }
	
	RWL_RDLOCK(&fdata->lock);
	CHECK_MAXCLIENT(fdata, client);
		if (!(fdata->clients[client] & LF_OPEN)) fdata->clients[client] |= LF_OPEN; /* file opened */
		else {  /* file ALREADY open */
			RWL_UNLOCK(&fdata->lock);
			errno = EBADF;
			return -1;
		}
	/* 
	The locking operation if (locking == true) will:
		- either succeed (=> LF_WRITE needs to be unset);
		- or fail because of connection closing or fatal error (=> LF_WRITE becomes "useless").
	*/
	fdata->clients[client] &= ~LF_WRITE;
	RWL_UNLOCK(&fdata->lock);
	
	if (locking){
		RWL_WRLOCK(&fdata->lock);
		CHECK_MAXCLIENT(fdata, client);
		int ret = fdata_lock(fdata, client);
		if (ret == -1){
			fdata->clients[client] &= ~LF_OPEN; /* Operation failed */
			int errno_copy = errno;
			RWL_UNLOCK(&fdata->lock);
			errno = errno_copy;
			return -1;
		}
		RWL_UNLOCK(&fdata->lock);
		return ret;
	} else return 0;
}


/**
 * @brief Closes the current file for client identified by #client param.
 * @return 0 on success, -1 on error.
 * Possible errors are:
 *	- EINVAL: invalid arguments (fdata == NULL, client < 0, client > fdata->maxclient);
 *	- EPERM: file not valid;
 *	- EBADF: file not open;
 *	- any error by rwlock_write_*.
 */
int fdata_close(fdata_t* fdata, int client){ /* -> fss_close */
	if (!fdata || (client < 0)){
		errno = EINVAL;
		return -1;
	}
	
	RWL_RDLOCK(&fdata->lock);
	
	CHECK_MAXCLIENT(fdata, client);
	
	if (fdata->clients[client] & LF_OPEN) fdata->clients[client] &= ~LF_OPEN; /* file closed */
	else { /* file NOT open */
		RWL_UNLOCK(&fdata->lock);
		errno = EBADF;
		return -1;
	}
	
	fdata->clients[client] &= ~LF_WRITE; /* A writeFile will fail */
	
	RWL_UNLOCK(&fdata->lock);

	return 0;
}


/**
 * @brief Copies file data (if any) into a buffer (usually returned to a fss_t object).
 * @param ign_open -- If true, then it is ignored whether the file is open or not (this is needed to implement readNFiles); otherwise, it is checked (normal read).
 * @return 0 on success, -1 on error.
 * Possible errors are:
 *	- EINVAL: invalid arguments (fdata == NULL, client < 0, client > fdata->maxclient);
 *	- EPERM: file not valid;
 *	- EBADF: file not open;
 *	- ENOMEM: unablòe to allocate needed memory;
 *	- EBUSY: file is locked by another client;
 *	- any error by rwlock_read_*.
 */
int fdata_read(fdata_t* fdata, void** buf, size_t* size, int client, bool ign_open){ /* -> fss_read */
	if (!fdata || !buf || !size || (client < 0)){
		errno = EINVAL;
		return -1;
	}
	
	RWL_RDLOCK(&fdata->lock);
	
	CHECK_MAXCLIENT(fdata, client);
	
	/* If ign_open == true, this check shall be skipped */
	if (!ign_open && (fdata->flags & O_LOCK) && !(fdata->clients[client] & LF_OWNER)){
		RWL_UNLOCK(&fdata->lock);
		errno = EBUSY;
		return -1;
	}
	
	/* If ign_open == true, check on LF_OPEN shall be skipped */
	if (ign_open || (fdata->clients[client] & LF_OPEN)) { /* file open */
		*buf = malloc(fdata->size);
		if (*buf == NULL){
			RWL_UNLOCK(&fdata->lock);
			errno = ENOMEM;
			return -1;
		} else {
			memset(*buf, 0, fdata->size);
			memcpy(*buf, fdata->data, fdata->size); //FIXME Sostituire con memmove
			*size = fdata->size;
		}
	} else { /* !ign_open && !(LF_OPEN set) */
		RWL_UNLOCK(&fdata->lock);
		errno = EBADF;
		return -1; /* file NOT open */
	}

	/* This is ok also for readNFiles: LF_WRITE is reset iff this file is chosen */
	fdata->clients[client] &= ~LF_WRITE; /* A writeFile will fail */

	RWL_UNLOCK(&fdata->lock);
	
	return 0;
}


/**
 * @brief Writes at most size bytes from the location pointed by buf by client.
 * @return 0 on success, -1 on error.
 * Possible errors are:
 *	- EINVAL: invalid arguments (fdata == NULL, client < 0, client > fdata->maxclient);
 *	- EPERM: file not valid;
 *	- EBADF: file not open or it is not possible to write in it
 *	(wr == true, i.e. a writeFile fails);
 *	- EBUSY: file is locked by another client;
 *	- ENOMEM: by malloc/realloc;
 *	- any error by rwlock_write_*.
 */
int	fdata_write(fdata_t* fdata, void* buf, size_t size, int client, bool wr){

	if (!fdata || !buf || (size < 0) || (client < 0)){
		errno = EINVAL;
		return -1;
	}

	RWL_WRLOCK(&fdata->lock);
	
	CHECK_MAXCLIENT(fdata, client);
	
	if ((fdata->flags & O_LOCK) && !(fdata->clients[client] & LF_OWNER)){ /* File is locked by another client */
		RWL_UNLOCK(&fdata->lock);
		errno = EBUSY;
		return -1;
	}
	
	if (!(fdata->clients[client] & LF_OPEN)) {
		RWL_UNLOCK(&fdata->lock);
		errno = EBADF;
		return -1;
	}
	
	if (wr && !(fdata->clients[client] & LF_WRITE)){
		RWL_UNLOCK(&fdata->lock);
		errno = EBADF;
		return -1;
	}
	
	if (!fdata->data){
		fdata->data = malloc(size);
		if (!fdata->data){
			RWL_UNLOCK(&fdata->lock);
			errno = ENOMEM;
			return -1;
		} else {
			fdata->size = size;
			memcpy(fdata->data, buf, size); //TODO Sostituire con memmove
		}
	} else {
		size_t newsize = fdata->size + size;
		void* ptr = realloc(fdata->data, newsize);
		if (!ptr){
			RWL_UNLOCK(&fdata->lock);
			errno = ENOMEM;
			return -1;
		} else {
			fdata->data = ptr;
			memcpy(((char*)fdata->data) + fdata->size, (char*)buf, size); //TODO Sostituire con memmove
			fdata->size = newsize;
		}
	}
	
	/* Modified (ONLY when appending content to file) */
	if (!wr) fdata->flags |= O_DIRTY;

	fdata->clients[client] &= ~LF_WRITE; /* A writeFile will fail */

	RWL_UNLOCK(&fdata->lock);

	return 0;
}


/**
 * @brief Sets O_LOCK flag to the current file. If O_LOCK is not set
 * or it is already owned by the calling client, it returns 0 immediately,
 * otherwise it returns 1.
 * @return 0 on success, -1 on error, 1 if file is already locked by another client.
 * Possible errors are:
 *	- EINVAL: invalid arguments (fdata == NULL, client < 0, client > fdata->maxclient);
 */
int fdata_lock(fdata_t* fdata, int client){
	if (!fdata || (client < 0)){
		errno = EINVAL;
		return -1;
	}
	
	RWL_WRLOCK(&fdata->lock);
	
	CHECK_MAXCLIENT(fdata, client);
	
	if ((fdata->flags & O_LOCK) && !(fdata->clients[client] & LF_OWNER)){
		int* wfd = malloc(sizeof(int));
		if (!wfd){
			RWL_UNLOCK(&fdata->lock);
			errno = ENOMEM;
			return -1;
		}
		*wfd = client;
		int w = tsqueue_push(fdata->waiting, wfd);
		if (w == 0){
			fdata->clients[client] |= LF_WAIT;
			RWL_UNLOCK(&fdata->lock);
			return 1;
		} else {
			free(wfd);
			RWL_UNLOCK(&fdata->lock);
			return -1;
		}
	} else {
		fdata->flags |= O_LOCK;
		fdata->clients[client] |= LF_OWNER;
	}
	
	fdata->clients[client] &= ~LF_WRITE; /* A writeFile will fail */
	RWL_UNLOCK(&fdata->lock);
	
	return 0;
}


/**
 * @brief Resets O_LOCK flag to the current file. If file was not locked by the calling
 * client, it returns 1 immediately.
 * @param newowner -- Pointer to an integer where new lock onwer will be stored (if any).
 * @return 0 on success, -1 on (general) error, -2 if file has been invalidated,
 * 1 if file was not already locked by the calling client.
 * Possible errors are:
 *	- EINVAL: invalid arguments (fdata == NULL, client < 0, client > fdata->maxclient);
 */
int fdata_unlock(fdata_t* fdata, int client, llist_t** newowner){

	if (!fdata || (client < 0) || !newowner){
		errno = EINVAL;
		return -1;
	}
	
	int* n_own = NULL;
	
	RWL_WRLOCK(&fdata->lock);
	
	CHECK_MAXCLIENT(fdata, client);
	
	if (fdata->clients[client] & LF_OWNER){
		fdata->clients[client] &= ~LF_OWNER;
		int w = tsqueue_pop(fdata->waiting, &n_own, true); /* nonblocking */
		if (w > 0) fdata->flags &= ~O_LOCK; /* No one is waiting or queue is closed */
		else if (w == 0){
			fdata->clients[*n_own] &= ~LF_WAIT;
			fdata->clients[*n_own] |= LF_OWNER;
			if (llist_push(*newowner, n_own) == -1){
				perror("fdata_unlock: while adding new owner to list");
				return -1;
			}
		} else {
			fdata->flags &= ~O_LOCK; /* Unlocks it however */ //FIXME Sure??
			int errno_copy = errno;
			RWL_UNLOCK(&fdata->lock);
			errno = errno_copy;
			return -1;
		}
	} else {
		RWL_UNLOCK(&fdata->lock);
		return 1;
	}
	
	fdata->clients[client] &= ~LF_WRITE; /* A writeFile will fail */	
	RWL_UNLOCK(&fdata->lock);

	return 0;
}


/**
 * @brief Removes all data of a client, i.e.:
 *	- clears all its local flags;
 *	- if it is owning lock on file, unlocks it;
 *	- if it is waiting on file, removes it from waiting list.
 * @return 0 on success, -1 on error, -2 if file is invalidated
 * during the process.
 * Possible errors are:
 *	- EINVAL: invalid arguments (fdata == NULL, client < 0, client > fdata->maxclient);
 */
int fdata_removeClient(fdata_t* fdata, int client, llist_t** newowner){
	if (!fdata || (client < 0) || !newowner){
		errno = EINVAL;
		return -1;
	}
	int ret = 0;
	//*newowner = NULL;
	
	RWL_WRLOCK(&fdata->lock);
	
	CHECK_MAXCLIENT(fdata, client);
	
	fdata->clients[client] &= ~(LF_OPEN | LF_WRITE); /* These can be safely eliminated here */
	
	if (fdata->clients[client] & LF_WAIT){
		if (tsqueue_iter_init(fdata->waiting) == -1){
			RWL_UNLOCK(&fdata->lock);
			return -1;
		}
		int* r;
		int res1, res2;
		while ( (res1 = tsqueue_iter_next(fdata->waiting, &r)) == 0){
			if (*r == client){
				if ((res2 = tsqueue_iter_remove(fdata->waiting, &r)) == -1){ /* queue is untouched */
					tsqueue_iter_end(fdata->waiting);
					RWL_UNLOCK(&fdata->lock);
					return -1;
				} else if (res2 == 0) free(r);
				break;
			}
		}
		//TODO Andrebbe sostituita con una SYSCALL_EXIT (anche la init e la tsqueue_iter_end di sopra)
		if (tsqueue_iter_end(fdata->waiting) == -1){ //FIXME Va messa qui??
			RWL_UNLOCK(&fdata->lock);
			return -1;
		}
		if (res1 == -1){ /* Error on iteration */
			RWL_UNLOCK(&fdata->lock);
			return -1;
		}
		/* If (res1 == 1), iteration has ended without finding client in the waiting queue */
		fdata->clients[client] &= ~LF_WAIT;
	} else if (fdata->clients[client] & LF_OWNER){
		ret = fdata_unlock(fdata, client, newowner); /* ret will NEVER be 1 */
	}

	RWL_UNLOCK(&fdata->lock);
	
	return ret;
}


tsqueue_t* fdata_waiters(fdata_t* fdata){
	if (!fdata){ errno = EINVAL; return NULL; }
	
	RWL_WRLOCK(&fdata->lock);
	tsqueue_t* waitQueue = fdata->waiting;
	fdata->waiting = NULL;
	for (int i = 0; i < fdata->maxclient; i++) fdata->clients[i] &= ~LF_WAIT;
	RWL_UNLOCK(&fdata->lock);
	return waitQueue;
}


/**
 * @brief Removes file from file storage and cancels all its data.
 * @param waiting -- An ALREADY initialized linkedlist of all clients
 * waiting for the lock on this file.
 * Possible errors can be:
 *	- EINVAL (invalid arguments);
 *	- any error returned by rwlock_write_*.
 */
void fdata_destroy(fdata_t* fdata){
	if (!fdata){ errno = EINVAL; return; }

	RWL_WRLOCK(&fdata->lock);
	if (fdata->clients){
		free(fdata->clients);
		fdata->clients = NULL;
	}
	fdata->size = 0;
	fdata->maxclient = 0;
	if (fdata->data){
		free(fdata->data);
		fdata->data = NULL;	
	}
	if (fdata->waiting){
		tsqueue_destroy(fdata->waiting, free);
		fdata->waiting = NULL;
	}
	RWL_UNLOCK(&fdata->lock);

	RWL_DESTROY(&fdata->lock);

	free(fdata);
}


/**
 * @brief Prints out all metadata and file content of the file.
 */
void fdata_printout(fdata_t* fdata){
	RWL_RDLOCK(&fdata->lock);
	printf("fdata->size = %lu\n", fdata->size);
	printf("fdata->flags = %d\n", fdata->flags);
	printf("locked(fdata) = ");
	printf(fdata->flags & O_LOCK ? "true\n" : "false\n");
	printf("fdata->maxclient = %d\n", fdata->maxclient);
	printf("fdata->clients = ");
	for (int i = 0; i <= fdata->maxclient; i++){
		if (fdata->clients[i] & LF_OPEN) printf("1");
		else printf("0");
	}
	printf("\nfile content: \n");
	write(1, fdata->data, fdata->size); /* Avoid invalid reads in absence of '\0' character */
	printf("\n");
	RWL_UNLOCK(&fdata->lock);
}
