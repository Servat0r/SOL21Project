#include <fdata.h>

/**
 * @brief Resizes the current array of clients such that client can be inserted in.
 * @return 0 on success (client is suitable for current length, or fdata->clients has
 * been correctly realloc'd), -1 on error.
 * Possible errors are:
 *	- ENOMEM (system out of memory, set by malloc);
 */
static int fdata_resize(fdata_t* fdata, int client){
	if (client <= fdata->maxclient) return 0;
	unsigned char* ptr = malloc((client + 1) * sizeof(char));
	if (!ptr){ errno = ENOMEM; return -1; }
	else {
		memset(ptr, 0, (client + 1)*sizeof(char));
		memmove((unsigned char*)ptr, (unsigned char*)fdata->clients, (fdata->maxclient + 1)*CHSIZE);
		free(fdata->clients);
		fdata->clients = ptr;
		fdata->maxclient = MAX(fdata->maxclient, client);
		return 0;
	}
}

/**
 * @brief Initializes a fdata_t object to contain an empty (closed) file and a (current) number of
 * possible opening clients of nclients.
 * @return Pointer to fdata_t object on success, NULL on error.
 * Possible errors are:
 *	- EINVAL (creator > maxclient);
 *	- ENOMEM (system out of memory, set by malloc / calloc);
 *	- any error generated by rwlock_init.
 */
fdata_t* fdata_create(int maxclient, int creator){ /* -> fss_create */
	if (creator > maxclient){
		errno = EINVAL;
		return NULL;
	}
	fdata_t* fdata = malloc(sizeof(fdata_t));
	if (!fdata){
		errno = ENOMEM;
		return NULL;
	}
	memset(fdata, 0, sizeof(fdata_t));
	fdata->data = NULL;
	fdata->size = 0; /* Per semplicitÃ  */

	
	fdata->clients = malloc((maxclient + 1) * sizeof(char));
	if (!fdata->clients){ errno = ENOMEM; free(fdata); return NULL; }
	memset(fdata->clients, 0, (maxclient + 1)*sizeof(char));
	fdata->maxclient = maxclient;
	
	if (rwlock_init(&fdata->lock) != 0){
		free(fdata->clients);
		free(fdata);
		return NULL;
	}
	
	/* Gives access to creator */
	fdata->clients[creator] = LF_OPEN;
	fdata->flags = GF_VALID; /* Valid */
	
	return fdata;
}

/**
 * @brief Open fdata->data for client identified by client (connection
 * file descriptor).
 * @return 0 on success, -1 on error.
 * Possible errors are:
 *	- EINVAL (invalid arguments);
 *	- EPERM (file not valid);
 *	- EBADF (file already open);
 *	- ENOMEM (by fdata_resize);
 *	- any error by rwlock_write_*.
 */
int fdata_open(fdata_t* fdata, int client){ /* -> fss_open */

	if (!fdata){ errno = EINVAL; return -1; }
	int ret = 0;
	
	rwlock_write_start(&fdata->lock);
	
	if ((fdata->flags & GF_VALID) == 0){ /* File NOT valid */
		errno = EPERM; 
		rwlock_write_finish(&fdata->lock);
		return -1;
	}

	if (client > fdata->maxclient){
		if (fdata_resize(fdata, client) == -1){
			fprintf(stderr, "Error while resizing #clients\n");
			rwlock_write_finish(&fdata->lock);
			return -1; /* Propagates ENOMEM */
		}
	}

	if (!(fdata->clients[client] & LF_OPEN)) fdata->clients[client] = fdata->clients[client] | LF_OPEN; /* file opened */
	else {errno = EBADF; ret = -1; } /* file ALREADY open */

	rwlock_write_finish(&fdata->lock);
	
	return ret;
}

/**
 * @brief Closes the current file for client identified by #client param.
 * @return 0 on success, -1 on error.
 * Possible errors are:
 *	- EINVAL (invalid arguments);
 *	- EPERM (file not valid);
 *	- EBADF (file not open);
 *	- any error by rwlock_write_*.
 */
int fdata_close(fdata_t* fdata, int client){ /* -> fss_close */
	if (!fdata){ errno = EINVAL; return -1; }
	int ret = 0;
	
	rwlock_write_start(&fdata->lock);
	
	if ((fdata->flags & GF_VALID) == 0){ /* File NOT valid */
		errno = EPERM; 
		rwlock_write_finish(&fdata->lock);
		return -1;
	}

	if (client > fdata->maxclient){ errno = EBADF; return -1; }
	
	if (fdata->clients[client] & LF_OPEN) fdata->clients[client] = fdata->clients[client] & !LF_OPEN; /* file closed */
	else ret = -1; /* file NOT open */
	rwlock_write_finish(&fdata->lock);

	return ret;
}

/**
 * @brief Copies file data (if any) into a buffer (usually returned to
 * a fss_t object).
 * @return 0 on success, -1 on error.
 * Possible errors are:
 *	- EINVAL (invalid arguments);
 *	- EPERM (file not valid);
 *	- EBADF (file not open);
 *	- ENOMEM (by malloc);
 *	- any error by rwlock_read_*.
 */
int fdata_read(fdata_t* fdata, void** buf, int client){ /* -> fss_read */
	if (!fdata || !buf){ errno = EINVAL; return -1; }
	int ret = 0;
	
	rwlock_read_start(&fdata->lock);

	if (client > fdata->maxclient){ errno = EBADF; return -1; }
	if ((fdata->flags & GF_VALID) == 0){ /* File NOT valid */
		errno = EPERM; 
		rwlock_read_finish(&fdata->lock);
		return -1;
	}
	
	if (fdata->clients[client] & LF_OPEN) { /* file open */
		*buf = malloc(fdata->size);
		memset(*buf, 0, fdata->size);
		if (*buf == NULL) ret = -1;
		else memcpy(*buf, fdata->data, fdata->size);
	}
	else ret = -1; /* file NOT open */

	rwlock_read_finish(&fdata->lock);
	
	return ret;
}

/**
 * @brief Checks if 'client' can 'upload' the content of the
 * (corresponding) file on disk, i.e. if a writeFile by client
 * will NOT fail. This is true iff:
 *	- GF_LOCKED and GF_UPLOAD are set;
 *	- GF_DIRTY is NOT set;
 *	- LF_OPEN and LF_OWNER for client are set.
 * Possible errors are:
 *	- EINVAL (invalid arguments);
 */
bool fdata_canUpload(fdata_t* fdata, int client){
	if ((!fdata) || (client > fdata->maxclient)){ errno = EINVAL; return false; }
	bool gf = (fdata->flags & GF_LOCKED) && (fdata->flags & GF_UPLOAD) && (fdata->flags % GF_DIRTY != 0);
	bool lf = (fdata->clients[client] & LF_OPEN) && (fdata->clients[client] & LF_OWNER);
	return (gf && lf);
}

/**
 * @brief Writes at most size bytes from the location pointed by buf by client.
 * @return 0 on success, -1 on error.
 * Possible errors are:
 *	- EINVAL (invalid arguments);
 *	- EPERM (file not valid);
 *	- EBADF (file not open);
 *	- ENOMEM (by malloc/realloc);
 *	- any error by rwlock_write_*.
 * If ENOMEM is returned as error, above file storage MUST destroy this object.
 */
int	fdata_write(fdata_t* fdata, void* buf, size_t size, int client){

	int ret = 0;

	rwlock_write_start(&fdata->lock);

	if ((fdata->flags & GF_VALID) == 0){ /* File NOT valid */
		errno = EPERM; 
		rwlock_write_finish(&fdata->lock);
		return -1;
	}
	
	if (client > fdata->maxclient) {
		errno = EBADF;
		rwlock_write_finish(&fdata->lock);
		return -1;
	}
	
	if (!(fdata->clients[client] && LF_OPEN)) {
		errno = EBADF;
		rwlock_write_finish(&fdata->lock);
		return -1;
	}

	if (!fdata->data){
		fdata->data = malloc(size);
		if (!fdata->data){
			errno = ENOMEM;
			fdata->flags = fdata->flags & !GF_VALID; /* Invalid file */
			rwlock_write_finish(&fdata->lock);
			return -1;
		} else {
			fdata->size = size;
			memcpy(fdata->data, buf, size);
		}
	} else {
		size_t newsize = fdata->size + size;
		fdata->data = realloc(fdata->data, newsize); /* FIXME If it is NULL, this could lead to memory bugs */
		if (!fdata->data){ /* FATAL ERROR */
			errno = ENOMEM;
			fdata->flags = fdata->flags & !GF_VALID; /* Invalid file */
			rwlock_write_finish(&fdata->lock);
			return -1;
		} else {
			memset(((unsigned char*)fdata->data) + fdata->size, 0, size);
			memmove(((unsigned char*)fdata->data) + fdata->size, (unsigned char*)buf, size);
			fdata->size = newsize;
		}
	}
	
	fdata->flags = (fdata->flags | GF_DIRTY); /* Modified (we consider ONLY appending writes for now)*/
	rwlock_write_finish(&fdata->lock);

	return ret;
}

/**
 * @brief Removes file from file storage and cancels all its data. This function can be
 * called only by the server when it is terminating to destroy all its files, if locking
 * on files is NOT supported.
 * @return 0 on success, -1 on error.
 * Possible errors can be:
 *	- EINVAL (invalid arguments);
 *	- EBADF (locking supported, file not open);
 *	- any error returned by rwlock_write_*.
 */
int	fdata_remove(fdata_t* fdata){ /* Implicit usage of 'free' (it is ALL heap-allocated for this struct) */
	if (!fdata){ errno = EINVAL; return -1; }

	rwlock_write_start(&fdata->lock);
	free(fdata->clients);
	fdata->size = 0;
	fdata->maxclient = 0;

	if (fdata->flags & GF_VALID) free(fdata->data); /* File content valid */

	rwlock_write_finish(&fdata->lock);

	rwlock_destroy(&fdata->lock);

	free(fdata);

	return 0;
}

void fdata_printout(fdata_t* fdata){
	printf("fdata->size = %lu\n", fdata->size);
	printf("fdata->flags = %d", fdata->flags);
	printf("fdata->clients = ");
	for (int i = 0; i <= fdata->maxclient; i++){
		if (fdata->clients[i] & LF_OPEN) printf("1");
		else printf("0");
	}
	printf("\n");
}
