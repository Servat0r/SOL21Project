#include <fdata.h>

/**
 * @brief Resizes the current array of clients such that client can be inserted in.
 * @return 0 on success (client is suitable for current length, or fdata->clients has
 * been correctly realloc'd), -1 on error.
 * Possible errors are:
 *	- ENOMEM (system out of memory, set by malloc);
 */
static int fdata_resize(fdata_t* fdata, int client){
	if (client <= fdata->maxclient) return 0;
	unsigned char* ptr = realloc(fdata->clients, (client + 1) * sizeof(char));
	if (!ptr){ errno = ENOMEM; return -1; }
	else {
		fdata->clients = ptr;
		memset(fdata->clients + fdata->maxclient + 1, 0, (client - fdata->maxclient)*sizeof(char));
		fdata->maxclient = client;
		return 0;
	}
}

/**
 * @brief Initializes a fdata_t object to contain an empty (closed) file and a (current) number of
 * possible opening clients of nclients.
 * @return Pointer to fdata_t object on success, NULL on error.
 * Possible errors are:
 *	- EINVAL (creator > maxclient);
 *	- ENOMEM (system out of memory, set by malloc / calloc);
 *	- any error generated by rwlock_init.
 */
fdata_t* fdata_create(int maxclient, int creator){ /* -> fss_create */
	if (creator > maxclient){
		errno = EINVAL;
		return NULL;
	}
	fdata_t* fdata = malloc(sizeof(fdata_t));
	if (!fdata){
		errno = ENOMEM;
		return NULL;
	}
	memset(fdata, 0, sizeof(fdata_t));
	fdata->data = NULL;
	fdata->size = 0;
	fdata->flags = GF_VALID; /* Valid */
	
	fdata->clients = malloc((maxclient + 1) * sizeof(char));
	if (!fdata->clients){ errno = ENOMEM; free(fdata); return NULL; }
	memset(fdata->clients, 0, (maxclient + 1)*sizeof(char));
	fdata->maxclient = maxclient;
	
	if (rwlock_init(&fdata->lock) != 0){
		free(fdata->clients);
		free(fdata);
		return NULL;
	}
	
	/* Gives access to creator */
	fdata->clients[creator] = LF_OPEN;

	return fdata;
}

/**
 * @brief Open fdata->data for client identified by client (connection
 * file descriptor).
 * @return 0 on success, -1 on error.
 * Possible errors are:
 *	- EINVAL (invalid arguments);
 *	- EPERM (file not valid);
 *	- EBADF (file already open);
 *	- ENOMEM (by fdata_resize);
 *	- any error by rwlock_write_*.
 */
int fdata_open(fdata_t* fdata, int client){ /* -> fss_open */

	if (!fdata){ errno = EINVAL; return -1; }
	int ret = 0;
	
	rwlock_read_start(&fdata->lock);
	
	if ((fdata->flags & GF_VALID) == 0){ /* File NOT valid */
		errno = EPERM; 
		rwlock_write_finish(&fdata->lock);
		return -1;
	}

	if (client > fdata->maxclient){
		/* We need to modify shared structs */
		rwlock_read_finish(&fdata->lock);
		rwlock_write_start(&fdata->lock);
		if (fdata_resize(fdata, client) == -1){
			perror("Error while resizing #clients\n");
			rwlock_write_finish(&fdata->lock);
			return -1; /* Propagates ENOMEM */
		} else {
			rwlock_write_finish(&fdata->lock);
			rwlock_read_start(&fdata->lock);
		}
	}

	if (!(fdata->clients[client] & LF_OPEN)) fdata->clients[client] |= LF_OPEN; /* file opened */
	else {errno = EBADF; ret = -1; } /* file ALREADY open */

	rwlock_read_finish(&fdata->lock);
	
	return ret;
}


/**
 * @brief Closes the current file for client identified by #client param.
 * @return 0 on success, -1 on error.
 * Possible errors are:
 *	- EINVAL (invalid arguments);
 *	- EPERM (file not valid);
 *	- EBADF (file not open);
 *	- any error by rwlock_write_*.
 */
int fdata_close(fdata_t* fdata, int client){ /* -> fss_close */
	if (!fdata){ errno = EINVAL; return -1; }
	int ret = 0;
	
	rwlock_write_start(&fdata->lock);
	
	if ((fdata->flags & GF_VALID) == 0){ /* File NOT valid */
		errno = EPERM; 
		rwlock_write_finish(&fdata->lock);
		return -1;
	}

	if (client > fdata->maxclient){ errno = EBADF; return -1; }
	
	if (fdata->clients[client] & LF_OPEN) fdata->clients[client] &= ~LF_OPEN; /* file closed */
	else ret = -1; /* file NOT open */
	rwlock_write_finish(&fdata->lock);

	return ret;
}

/**
 * @brief Copies file data (if any) into a buffer (usually returned to
 * a fss_t object).
 * @return 0 on success, -1 on error.
 * Possible errors are:
 *	- EINVAL (invalid arguments);
 *	- EPERM (file not valid);
 *	- EBADF (file not open);
 *	- ENOMEM (by malloc);
 *	- any error by rwlock_read_*.
 */
int fdata_read(fdata_t* fdata, void** buf, size_t* size, int client){ /* -> fss_read */
	if (!fdata || !buf){ errno = EINVAL; return -1; }
	int ret = 0;
	
	rwlock_read_start(&fdata->lock);

	if (client > fdata->maxclient){ errno = EBADF; return -1; }
	if ((fdata->flags & GF_VALID) == 0){ /* File NOT valid */
		errno = EPERM; 
		rwlock_read_finish(&fdata->lock);
		return -1;
	}
	
	if (fdata->clients[client] & LF_OPEN) { /* file open */
		*buf = malloc(fdata->size);
		if (*buf == NULL) ret = -1;
		else {
			memset(*buf, 0, fdata->size);
			memcpy(*buf, fdata->data, fdata->size);
			*size = fdata->size;
		}
	}
	else ret = -1; /* file NOT open */

	rwlock_read_finish(&fdata->lock);
	
	return ret;
}

/**
 * @brief Checks if 'client' can 'upload' the content of the
 * (corresponding) file on disk, i.e. if a writeFile by client
 * will NOT fail. This is true iff:
 *	- GF_LOCKED and GF_UPLOAD are set;
 *	- GF_DIRTY is NOT set;
 *	- LF_OPEN and LF_OWNER for client are set.
 * Possible errors are:
 *	- EINVAL (invalid arguments);
 */
bool fdata_canUpload(fdata_t* fdata, int client){
	if ((!fdata) || (client > fdata->maxclient)){ errno = EINVAL; return false; }
	bool gf = (fdata->flags & GF_LOCKED) && (fdata->flags & GF_UPLOAD) && !(fdata->flags & GF_DIRTY);
	bool lf = (fdata->clients[client] & LF_OPEN) && (fdata->clients[client] & LF_OWNER);
	return (gf && lf);
}

/**
 * @brief Returns current TOTAL memory space occupied
 * by the #fdata object.
 * @returns size of the #fdata object, 0 if fdata == NULL.
 */
size_t fdata_totalSize(fdata_t* fdata){
	if (!fdata) return 0;
	size_t size = sizeof(*fdata);
	size += fdata->size; /* Data size */
	for (int i = 0; i <= fdata->maxclient; i++) size += 1; /* Client byte-array size (avoids overflow) */
	return size;
}

/**
 * @brief Writes at most size bytes from the location pointed by buf by client.
 * @return 0 on success, -1 on error.
 * Possible errors are:
 *	- EINVAL (invalid arguments);
 *	- EPERM (file not valid);
 *	- EBADF (file not open);
 *	- ENOMEM (by malloc/realloc);
 *	- any error by rwlock_write_*.
 * If ENOMEM is returned as error, above file storage MUST destroy this object.
 */
int	fdata_write(fdata_t* fdata, void* buf, size_t size, int client){

	int ret = 0;

	rwlock_write_start(&fdata->lock);


	if ((fdata->flags & GF_VALID) == 0){ /* File NOT valid */
		errno = EPERM; 
		rwlock_write_finish(&fdata->lock);
		return -1;
	}
	
	if (client > fdata->maxclient) {
		errno = EBADF;
		rwlock_write_finish(&fdata->lock);
		return -1;
	}
	
	if (!(fdata->clients[client] && LF_OPEN)) {
		errno = EBADF;
		rwlock_write_finish(&fdata->lock);
		return -1;
	}
	
	if (!fdata->data){
		fdata->data = malloc(size);
		if (!fdata->data){
			errno = ENOMEM;
			fdata->flags = fdata->flags & ~GF_VALID; /* Invalid file */
			rwlock_write_finish(&fdata->lock);
			return -1;
		} else {
			fdata->size = size;
			memcpy(fdata->data, buf, size);
		}
	} else {
		size_t newsize = fdata->size + size;
		void* ptr = realloc(fdata->data, newsize);
		if (!ptr){ /* FATAL ERROR */
			errno = ENOMEM;
			rwlock_write_finish(&fdata->lock);
			return -1;
		} else {
			fdata->data = ptr;
			//memset(((unsigned char*)fdata->data) + fdata->size, 0, size);
			memcpy(((char*)fdata->data) + fdata->size, (char*)buf, size);
			fdata->size = newsize;
		}
	}
	
	/* Modified (we consider ONLY appending writes for now)*/
	fdata->flags |= GF_DIRTY;
	fdata->flags &= ~GF_UPLOAD;
	rwlock_write_finish(&fdata->lock);

	return ret;
}


/**
 * @brief Removes file from file storage and cancels all its data. This function can be
 * called only by the server when it is terminating to destroy all its files, if locking
 * on files is NOT supported.
 * Possible errors can be:
 *	- EINVAL (invalid arguments);
 *	- EBADF (locking supported, file not open);
 *	- any error returned by rwlock_write_*.
 */
void fdata_destroy(fdata_t* fdata){
	if (!fdata){ errno = EINVAL; return; }

	rwlock_write_start(&fdata->lock);
	free(fdata->clients);
	fdata->size = 0;
	fdata->maxclient = 0;

	if (fdata->flags & GF_VALID) free(fdata->data); /* File content valid */

	rwlock_write_finish(&fdata->lock);

	rwlock_destroy(&fdata->lock);

	free(fdata);
}

void fdata_printout(fdata_t* fdata){
	rwlock_read_start(&fdata->lock);
	printf("fdata->size = %lu\n", fdata->size);
	printf("fdata->flags = %d\n", fdata->flags);
	printf("locked(fdata) = ");
	printf(fdata->flags & GF_LOCKED ? "true\n" : "false\n");
	printf("fdata->maxclient = %d\n", fdata->maxclient);
	printf("fdata->clients = ");
	for (int i = 0; i <= fdata->maxclient; i++){
		if (fdata->clients[i] & LF_OPEN) printf("1");
		else printf("0");
	}
	printf("\nfile content: \n");
	write(1, fdata->data, fdata->size); /* Avoid invalid reads in absence of '\0' character */
	printf("\nTotal size of file: %lu\n", fdata_totalSize(fdata));
	printf("\n");
	rwlock_read_finish(&fdata->lock);
}
