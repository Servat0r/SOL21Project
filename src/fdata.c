#include <fdata.h>


/**
 * @brief Resizes the current array of clients such that client can be inserted in.
 * @return 0 on success (client is suitable for current length, or fdata->clients has
 * been correctly realloc'd), -1 on error.
 * Possible errors are:
 *	- ENOMEM (system out of memory, set by malloc);
 */
static int fdata_resize(fdata_t* fdata, int client){
	if (client <= fdata->maxclient) return 0;
	unsigned char* ptr = realloc(fdata->clients, (client + 1) * sizeof(char));
	if (!ptr){ errno = ENOMEM; return -1; }
	else {
		fdata->clients = ptr;
		memset(fdata->clients + fdata->maxclient + 1, 0, (client - fdata->maxclient)*sizeof(char));
		fdata->maxclient = client;
		return 0;
	}
}


/**
 * @brief Initializes a fdata_t object to contain an empty (closed) file and a (current) number of
 * possible opening clients of nclients.
 * @return Pointer to fdata_t object on success, NULL on error.
 * Possible errors are:
 *	- EINVAL: invalid arguments;
 *	- ENOMEM (system out of memory, set by malloc / calloc);
 *	- any error generated by rwlock_init.
 */
fdata_t* fdata_create(int maxclient, int creator, bool locking){ /* -> fss_create */
	if ((creator > maxclient) || (creator < 0) || (maxclient < 0)){
		errno = EINVAL;
		return NULL;
	}
	fdata_t* fdata = malloc(sizeof(fdata_t));
	if (!fdata){
		errno = ENOMEM;
		return NULL;
	}
	memset(fdata, 0, sizeof(fdata_t));
	fdata->data = NULL;
	fdata->size = 0;
	fdata->flags = O_VALID; /* Valid */
	
	fdata->clients = malloc((maxclient + 1) * sizeof(char));
	if (!fdata->clients){
		free(fdata);
		errno = ENOMEM;
		return NULL;
	}
	memset(fdata->clients, 0, (maxclient + 1)*sizeof(char));
	fdata->maxclient = maxclient;
	
	if (pthread_rwlock_init(&fdata->lock, NULL) != 0){
		free(fdata->clients);
		free(fdata);
		return NULL;
	}
	
	/* Gives access to creator */
	fdata->clients[creator] = LF_OPEN;
	
	/* Gives ownership to creator if requested */
	if (locking){
		fdata->flags |= O_LOCK;
		fdata->clients[creator] |= (LF_OWNER | LF_WRITE);
	}

	return fdata;
}

/**
 * @brief Open fdata->data for client identified by client (connection
 * file descriptor).
 * @return 0 on success, -1 on error.
 * Possible errors are:
 *	- EINVAL: invalid arguments;
 *	- EPERM: file not valid;
 *	- EBADF: file already open;
 *	- ENOMEM: unable to allocate memory;
 *	- any error by rwlock_write_*.
 */
int fdata_open(fdata_t* fdata, int client, bool locking){ /* -> fss_open */

	if ((!fdata) || (client < 0)){ errno = EINVAL; return -1; }
	
	/* We could need to modify shared structs */
	pthread_rwlock_wrlock(&fdata->lock);
	if (fdata_resize(fdata, client) == -1){
		perror("Error while resizing #clients\n");
		pthread_rwlock_unlock(&fdata->lock);
		return -1; /* Propagates ENOMEM */
	}
	pthread_rwlock_unlock(&fdata->lock);
	pthread_rwlock_rdlock(&fdata->lock);
	
	if ((fdata->flags & O_VALID) == 0){ /* File NOT valid */
		pthread_rwlock_unlock(&fdata->lock);
		errno = EPERM;
		return -1;
	}

	if (locking){
		if ((fdata->flags & O_LOCK) && !(fdata->clients[client] & LF_OWNER)){ /* File is already locked by another client */
			pthread_rwlock_unlock(&fdata->lock);
			return 1;
		} else {
			fdata->flags |= O_LOCK;
			fdata->clients[client] |= LF_OWNER;
		}
	}
	
	if (!(fdata->clients[client] & LF_OPEN)) fdata->clients[client] |= LF_OPEN; /* file opened */
	else {  /* file ALREADY open */
		pthread_rwlock_unlock(&fdata->lock);
		errno = EBADF;
		return -1;
	}

	fdata->clients[client] &= ~LF_WRITE; /* A writeFile will fail */

	pthread_rwlock_unlock(&fdata->lock);
	
	return 0;
}


/**
 * @brief Closes the current file for client identified by #client param.
 * @return 0 on success, -1 on error.
 * Possible errors are:
 *	- EINVAL: invalid arguments;
 *	- EPERM: file not valid;
 *	- EBADF: file not open;
 *	- any error by rwlock_write_*.
 */
int fdata_close(fdata_t* fdata, int client){ /* -> fss_close */
	if (!fdata || (client < 0) || (client > fdata->maxclient)){
		errno = EINVAL;
		return -1;
	}
	
	pthread_rwlock_wrlock(&fdata->lock);
	
	if ((fdata->flags & O_VALID) == 0){ /* File NOT valid */
		pthread_rwlock_unlock(&fdata->lock);
		errno = EPERM;
		return -1;
	}
	
	if (fdata->clients[client] & LF_OPEN) fdata->clients[client] &= ~LF_OPEN; /* file closed */
	else { /* file NOT open */
		pthread_rwlock_unlock(&fdata->lock);
		errno = EBADF;
		return -1;
	}
	
	fdata->clients[client] &= ~LF_WRITE; /* A writeFile will fail */
	
	pthread_rwlock_unlock(&fdata->lock);

	return 0;
}


/**
 * @brief Copies file data (if any) into a buffer (usually returned to
 * a fss_t object).
 * @return 0 on success, -1 on error.
 * Possible errors are:
 *	- EINVAL: invalid arguments;
 *	- EPERM: file not valid;
 *	- EBADF: file not open;
 *	- ENOMEM: unablÃ²e to allocate needed memory;
 *	- EBUSY: file is locked by another client;
 *	- any error by rwlock_read_*.
 */
int fdata_read(fdata_t* fdata, void** buf, size_t* size, int client){ /* -> fss_read */
	if (!fdata || !buf || !size || (client < 0) || (client > fdata->maxclient)){
		errno = EINVAL;
		return -1;
	}
	int ret = 0;
	
	pthread_rwlock_rdlock(&fdata->lock);

	if (client > fdata->maxclient){ errno = EBADF; return -1; }
	if ((fdata->flags & O_VALID) == 0){ /* File NOT valid */
		pthread_rwlock_unlock(&fdata->lock);
		errno = EPERM;
		return -1;
	}
	
	if ((fdata->flags & O_LOCK) && !(fdata->clients[client] & LF_OWNER)){
		pthread_rwlock_unlock(&fdata->lock);
		errno = EBUSY;
		return -1;
	}
	
	if (fdata->clients[client] & LF_OPEN) { /* file open */
		*buf = malloc(fdata->size);
		if (*buf == NULL) ret = -1;
		else {
			memset(*buf, 0, fdata->size);
			memcpy(*buf, fdata->data, fdata->size);
			*size = fdata->size;
		}
	} else {
		pthread_rwlock_unlock(&fdata->lock);
		errno = EBADF;
		return -1; /* file NOT open */
	}

	fdata->clients[client] &= ~LF_WRITE; /* A writeFile will fail */

	pthread_rwlock_unlock(&fdata->lock);
	
	return ret;
}


/**
 * @brief Writes at most size bytes from the location pointed by buf by client.
 * @return 0 on success, -1 on error.
 * Possible errors are:
 *	- EINVAL: invalid arguments;
 *	- EPERM: file not valid;
 *	- EBADF: file not open or it is not possible to write in it
 *	(wr == true, i.e. a writeFile fails);
 *	- EBUSY: file is locked by another client;
 *	- ENOMEM: by malloc/realloc;
 *	- any error by rwlock_write_*.
 */
int	fdata_write(fdata_t* fdata, void* buf, size_t size, int client, bool wr){

	if (!fdata || !buf || (size < 0) || (client < 0) || (client > fdata->maxclient)){
		errno = EINVAL;
		return -1;
	}

	int ret = 0;

	pthread_rwlock_wrlock(&fdata->lock);


	if ((fdata->flags & O_VALID) == 0){ /* File NOT valid */
		errno = EPERM; 
		pthread_rwlock_unlock(&fdata->lock);
		return -1;
	}
	
	if ((fdata->flags & O_LOCK) && !(fdata->clients[client] & LF_OWNER)){
		errno = EBUSY;
		pthread_rwlock_unlock(&fdata->lock);
		return -1;
	}
	
	if (!(fdata->clients[client] & LF_OPEN)) {
		errno = EBADF;
		pthread_rwlock_unlock(&fdata->lock);
		return -1;
	}
	
	if (wr && !(fdata->clients[client] & LF_WRITE)){
		errno = EBADF;
		pthread_rwlock_unlock(&fdata->lock);
		return -1;
	}
	
	if (!fdata->data){
		fdata->data = malloc(size);
		if (!fdata->data){
			errno = ENOMEM;
			fdata->flags = fdata->flags & ~O_VALID; /* Invalid file */
			pthread_rwlock_unlock(&fdata->lock);
			return -1;
		} else {
			fdata->size = size;
			memcpy(fdata->data, buf, size);
		}
	} else {
		size_t newsize = fdata->size + size;
		void* ptr = realloc(fdata->data, newsize);
		if (!ptr){ /* FATAL ERROR */
			errno = ENOMEM;
			pthread_rwlock_unlock(&fdata->lock);
			return -1;
		} else {
			fdata->data = ptr;
			memcpy(((char*)fdata->data) + fdata->size, (char*)buf, size);
			fdata->size = newsize;
		}
	}
	
	/* Modified (we consider ONLY appending writes for now)*/
	fdata->flags |= O_DIRTY;

	fdata->clients[client] &= ~LF_WRITE; /* A writeFile will fail */

	pthread_rwlock_unlock(&fdata->lock);

	return ret;
}


/**
 * @brief Sets O_LOCK flag to the current file. If O_LOCK is not set
 * or it is already owned by the calling client, it returns 0 immediately,
 * otherwise it returns 1.
 * @return 0 on success, -1 on error, 1 if file is already locked by another client.
 */
int fdata_lock(fdata_t* fdata, int client){
	if (!fdata || (client < 0) || (client > fdata->maxclient)){
		errno = EINVAL;
		return -1;
	}
	int ret;
	pthread_rwlock_wrlock(&fdata->lock);
	if ((fdata->flags & O_LOCK) && !(fdata->clients[client] & LF_OWNER)) ret = 1;
	else {
		fdata->flags |= O_LOCK;
		fdata->clients[client] |= LF_OWNER;
		ret = 0;
	}
	
	fdata->clients[client] &= ~LF_WRITE; /* A writeFile will fail */

	pthread_rwlock_unlock(&fdata->lock);
	return ret;
}


/**
 * @brief Resets O_LOCK flag to the current file. If file was not locked by the calling
 * client, it returns 1 immediately.
 * @return 0 on success, -1 on error,1 if file was not already locked by the calling client.
 */
int fdata_unlock(fdata_t* fdata, int client){
	if (!fdata || (client < 0) || (client > fdata->maxclient)){
		errno = EINVAL;
		return -1;
	}
	int ret;
	pthread_rwlock_wrlock(&fdata->lock);
	if (fdata->clients[client] & LF_OWNER){
		fdata->flags &= ~O_LOCK;
		fdata->clients[client] &= ~LF_OWNER;
		ret = 0;
	} else ret = 1;
	
	fdata->clients[client] &= ~LF_WRITE; /* A writeFile will fail */	
	pthread_rwlock_unlock(&fdata->lock);

	return ret;
}


/**
 * @brief Removes file from file storage and cancels all its data.
 * Possible errors can be:
 *	- EINVAL (invalid arguments);
 *	- any error returned by rwlock_write_*.
 */
void fdata_destroy(fdata_t* fdata){
	if (!fdata){ errno = EINVAL; return; }

	pthread_rwlock_wrlock(&fdata->lock);
	free(fdata->clients);
	fdata->size = 0;
	fdata->maxclient = 0;

	if (fdata->flags & O_VALID) free(fdata->data); /* File content valid */

	pthread_rwlock_unlock(&fdata->lock);

	pthread_rwlock_destroy(&fdata->lock);

	free(fdata);
}


/**
 * @brief Prints out all metadata and file content of the file.
 */
void fdata_printout(fdata_t* fdata){
	pthread_rwlock_rdlock(&fdata->lock);
	printf("fdata->size = %lu\n", fdata->size);
	printf("fdata->flags = %d\n", fdata->flags);
	printf("locked(fdata) = ");
	printf(fdata->flags & O_LOCK ? "true\n" : "false\n");
	printf("fdata->maxclient = %d\n", fdata->maxclient);
	printf("fdata->clients = ");
	for (int i = 0; i <= fdata->maxclient; i++){
		if (fdata->clients[i] & LF_OPEN) printf("1");
		else printf("0");
	}
	printf("\nfile content: \n");
	write(1, fdata->data, fdata->size); /* Avoid invalid reads in absence of '\0' character */
	printf("\n");
	pthread_rwlock_unlock(&fdata->lock);
}
